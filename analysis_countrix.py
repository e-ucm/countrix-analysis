"""
Created on Fri May 06 11:18:38 2016

@author: crisal24

Developed as part of e-ucm development group.

"""

from __future__ import division
import numpy as np
import json
import csv
import os
import unicodedata
import time
import datetime


class AnalysisCountrix:

    """ Class for analysis of xAPI statements generated by Countrix game
    Countrix available at https://github.com/e-ucm/countrix/

    Attributes
    ----------
        questions : dict
            Dictionary to store questions data
        countries : dict
            Dictionary to store information of countries
			with capitals and continents
        players : dict
            Dictionary to store players data
        verbs: dict
            Dictionary to store xAPI verbs used
        results: dict
            Dictionary to store results of players
        count_minutes : numpy.array
            24x60 matrix to store users per minute

    Methods
    ----------
        load_data
        parsing
        parse_statement
        parse_question_statement
        parse_question_type
        update_peaks
        update_verbs
        update_score
        update_user_questions
        update_question
        update_results
        store_analysis_questions
        store_analysis_sessions
        store_analysis_results
        store_analysis_peaks
        store_analysis_xapi

    """

    def __init__(self):
        """ __init__ initializes class atributes questions, countries, players,
        verbs and results to be empty dictionaries. It also initializes the
        class atribute count_minutes to be a 24x60 matrix of zeros.
        It also calls load_data method to prepare the countries dictionary
        and parsing method to automatically start parsing.

        """

        self.questions = dict()
        self.countries = dict()
        self.players = dict()
        self.verbs = dict()
        self.results = dict()
        self.count_minutes = np.zeros((24, 60), dtype=list)
        self.load_data()
        self.parsing()

    def load_data(self):
        """ load_data reads data from geography data file
        and stores the information in countries dictionary

        """

        with open('Data/geography.csv', 'rb') as csv_file:
            reader = csv.reader(csv_file)
            # parse geography file storing the information of each country
            for row in reader:
                r = [unicode(cell, 'utf-8') for cell in row]
                # name, capital, continent
                self.countries[r[0]] = (r[1], r[3], r[2])

    def parsing(self):
        """ parsing main method, parses the xAPI statements
        and stores the analysis in csv files

        """

        with open('Data/xapi_statements_countrix.json') as data_file:
            with open('analysis_players.csv', 'wb') as csv_players:
                # load data
                data = json.load(data_file)
                statements = data["statements"]

                # prepares writer for players csv file
                players_fieldnames = ['timestamp', 'user', 'question', 'error']
                writerp = csv.DictWriter(csv_players,
                                         fieldnames=players_fieldnames)

                # statements parsing
                for i in range(len(statements)):
                    statement = statements[i]
                    self.parse_statement(statement, writerp)

                # stores results
                self.store_analysis_questions()
                self.store_analysis_results()
                self.store_analysis_sessions()
                self.store_analysis_peaks()
                self.store_analysis_xapi()

    def parse_statement(self, statement, writerp):
        """ parse_statement parses a single xAPI statement
        updating the corresponding dictionaries when necessary

        Parameters
        ----------
        statement : dict
            xAPI statement to parsse
        writerp : csv.DictWriter
            Writer to store information of player

        """

        user = statement["actor"]["name"]
        timestamp = statement["timestamp"]

        if user not in self.players:  # first statement of user
            beginning = timestamp
            self.players[user] = (beginning, beginning, 0, 0)
        else:  # update last time of user
            beginning, oldtime, questions, score = self.players[user]
            if timestamp > oldtime:
                self.players[user] = (beginning, timestamp, questions, score)

        # adds user to peaks
        self.update_peaks(user, timestamp)

        # update xAPI verb times used
        complete_verb = statement["verb"]["id"]
        verb = os.path.split(complete_verb)[-1]
        self.update_verbs(verb, timestamp)

        object_id = statement["object"]["id"]
        question = os.path.split(object_id)[-1]

        if question == "score":  # xAPI trace that updates/sets score value
            newscore = statement["result"] ["extensions"]\
                                ["http://rage-eu.com/xapi/extensions/value"]
            self.update_score(user, newscore)

        if verb == "preferred":  # xAPI trace of question answered
            self.parse_question_statement(statement, writerp)

    def parse_question_statement(self, statement, writerp):
        """ parse_question_statement parse a xAPI statement given
        that corresponds to a game question, updating the information for user,
        question and results after determining if the question was correctly
        answered or not

        Parameters
        ----------
        statement : dict
            xAPI statement corresponding to a question
        writerp : csv.DictWriter
            Writer to store information of player

        """

        user = statement["actor"]["name"]
        object_id = statement["object"]["id"]
        question = os.path.split(object_id)[-1]
        answer = statement["result"]["response"]
        timestamp = statement["timestamp"]

        def parse_question_type(question):
            """ parse_question_type receives a question name and determines
            its type parsing the name, according to the 4 known types
            of questions: Flag, IsCapitalOf, CountryOfCapital and Continent

            Parameters
            ----------
            question : string
                Question name

            Returns
            -------
            country : string
                Country name
            question_type : string
                Type of question of the 4 known types: Flag, IsCapitalOf,
                CapitalOfCountry or Continent
            key : integer
                Key to access the country information, its value is 0, 1 or 2
                depending on if the information needed is country name,
                capital or continent, respectively
            results_index : integer
                Index in which to store the user results information, its value
                is 0, 1, 2 or 3 corresponding to the 4 types of questions

            """

            # Question type 1: FLAG
            if question[-4:] == "Flag":
                country = question[:-4]
                key = 0  # country name
                question_type = "Flag"
                results_index = 0

            # Question type 2: ISCAPITALOF
            elif question[-11:] == "IsCapitalOf":
                country = question[:-11]
                key = 0  # country name
                question_type = "CountryOfCapital"
                results_index = 1

            # Question type 3: CAPITALOFCOUNTRY
            elif question[-7:] == "Capital":
                country = question[:-7]
                key = 1  # capital
                question_type = "CapitalOfCountry"
                results_index = 2

            # Question type 4: CONTINENT
            elif question[-9:] == "Continent":
                country = question[:-9]
                key = 2  # continent
                question_type = "Continent"
                results_index = 3
            else:
                country = ""
                question_type = ""
                key = 0
                results_index = 0

            return country, question_type, key, results_index

        self.update_user_questions(user)  # update number of questions answered

        country, question_type, key, results_index = parse_question_type(
                                                     question)

        if country in self.countries:
            correct = self.countries[country][key]
        else:
            correct = ""

        hit = (correct == answer)
        question = unicodedata.normalize('NFKD', question).encode(
                                                           'ascii', 'ignore')

        # updates question information
        self.update_question(question, question_type, hit, timestamp)
        # update results of user
        self.update_results(user, results_index, hit)

        # stores data of player
        writerp.writerow({'timestamp': timestamp, 'user': user,
                          'question': question, 'error': not hit})

    def update_peaks(self, user, timestamp):
        """ update_peaks updates the information of peaks of use in
        count_minutes array

        Parameters
        ----------
        user : string
            User identifier
        timestamp : string
            Timestamp at which the user interacted with the game

        """

        # time parsing to obtain hour and minute
        hour = int(timestamp[11:-7])
        minute = int(timestamp[-6:-4])

        # adds user to the minute of game use
        if not self.count_minutes[hour][minute]:
            self.count_minutes[hour][minute] = [user]
        elif user not in self.count_minutes[hour][minute]:
            self.count_minutes[hour][minute].append(user)

    def update_verbs(self, verb, timestamp):
        """ update_verbs updates the verbs dictionary increasing by one
        the number of times the verb given as parameter has been used

        Parameters
        ----------
        verb : string
            xAPI verb used
        timestamp : string
            Timestamp at which the verb was user

        """

        if verb in self.verbs:  # the verb had already appeared
            firstuse, times = self.verbs[verb]
            self.verbs[verb] = (firstuse, times+1)
        else:  # first time verb used
            self.verbs[verb] = (timestamp, 1)

    def update_score(self, user, newscore):
        """ update_score updates score of user in players dictionary

        Parameters
        ----------
        user : string
            User identifier
        newscore: integer
            Updated score of user

        """

        beginning, oldtime, questions, _ = self.players[user]
        self.players[user] = (beginning, oldtime, questions, newscore)

    def update_user_questions(self, user):
        """ update_user_questions increases by 1 the number of questions
        answered by the user given as parameter in players dictionary

        Parameters
        ----------
        user : string
            User identifier

        """

        beginning, oldtime, questions, score = self.players[user]
        self.players[user] = (beginning, oldtime, questions+1, score)

    def update_question(self, question, question_type, correct, timestamp):
        """ update_questions receives a question name and type
        and whether it has been answered correctly or wronlgy at time
        given by timestamp, and updates this information in questions
        dictionary

        Parameters
        ----------
        question : string
            Question name
        question_type : string
            Type of question of the 4 known types: Flag, IsCapitalOf,
            CapitalOfCountry or Continent
        correct : boolean
            True if and only if the question was correctly answered
        timestamp : string
            Time at which the question was answered

        """

        # analysis of times question has been answered
        if question in self.questions:
            # question already store: increase times answered
            answers, wrong, question_type, timestamp = self.questions[question]
            answers += 1
        else:
            # question not previously stored in dictionary
            answers = 1
            wrong = 0

        if not correct:  # increases number of wrong times answered
            wrong += 1

        # store/update data of question in dictionary
        self.questions[question] = (answers, wrong, question_type,
                                    timestamp)

    def update_results(self, user, results_index, correct):
        """ update_results updates the information of the user given as
		parameter in results dictionary for the question type specified
		by results_index. Whether it was correctly answered or not
        is determined by the value of correct parameter

        Parameters
        ----------
        user : string
            User identifier
        results_index : integer
            Index in which to store the user results information, its value
            is 0, 1, 2 or 3 corresponding to the 4 types of questions
        correct : boolean
            True if and only if the question was correctly answered

        """

        # if new user, add empty results
        for k in range(4):
            if (user, k) not in self.results:
                self.results[(user, k)] = (0, 0)

        correct_type, answer_type = self.results[(user, results_index)]
        if correct:  # increase number of correct answers
            correct_type += 1

        # store/update results in dictionary for the given question type
        self.results[(user, results_index)] = (correct_type, answer_type+1)

    def store_analysis_questions(self):
        """ store_analysis_questions stores the results of the analysis of
        questions determined in questions dictionary in a csv file

        """

        with open('analysis_questions.csv', 'wb') as csv_questions:
            questions_fieldnames = ['timestamp', 'question', 'qtype',
                                    'answered', 'errors', 'ratio']
            writerq = csv.DictWriter(csv_questions,
                                     fieldnames=questions_fieldnames)

            # for each question
            for k in self.questions.keys():
                answered, errors, question_type, timestamp = self.questions[k]
                # error ratio
                ratio = errors / answered

                # store data
                writerq.writerow({'timestamp': timestamp,
                                  'question': k,
                                  'qtype': question_type,
                                  'answered': answered,
                                  'errors': errors,
                                  'ratio': ratio})

    def store_analysis_sessions(self):
        """ store_analysis_sessions stores the results of the analysis of
        sessions determined as part of players dictionary in a csv file

        """

        with open('analysis_sessions.csv', 'wb') as csv_sessions:
            sessions_fieldnames = ['timestamp', 'user', 'time', 'questions']
            writers = csv.DictWriter(csv_sessions,
                                     fieldnames=sessions_fieldnames)

            # for each player
            for k in self.players.keys():
                beginning, end, questions, _ = self.players[k]

                # calculation of user's session time
                init_time = datetime.datetime.strptime(beginning,
                                                       "%Y-%m-%d" + 'T' +
                                                       "%H:%M:%S" + 'Z')
                init_time = time.mktime(init_time.timetuple()) * 1000
                end_time = datetime.datetime.strptime(end,
                                                      "%Y-%m-%d" + 'T' +
                                                      "%H:%M:%S" + 'Z')
                end_time = time.mktime(end_time.timetuple()) * 1000
                playtime = end_time - init_time
                if playtime > 0:
                    # store data
                    writers.writerow({'timestamp': beginning,
                                      'user': k,
                                      'time': playtime,
                                      'questions': questions})

    def store_analysis_results(self):
        """ store_analysis_results stores the results of the analysis of
        users results in the four question types determined in results
        dictionary in a csv file

        """

        with open('analysis_results.csv', 'wb') as csv_results:
            results_fieldnames = ['timestamp', 'user', 'flag', 'iscapitalof',
                                  'capitalofcountry', 'continent', 'score']
            writerr = csv.DictWriter(csv_results,
                                     fieldnames=results_fieldnames)
            users = list(set(k[0] for k in self.results.keys()))

            # for each user
            for u in users:
                myresults = ["", "", "", ""]
                # for each question type
                for i in range(4):
                    correct, answered = self.results[(u, i)]
                    if answered < 2:
                        myresults[i] = "nodata"
                    elif correct / answered < 0.5:
                        myresults[i] = "failed"
                    else:
                        myresults[i] = "passed"

                timestamp, _, _, score = self.players[u]

                # store data
                writerr.writerow({'timestamp': timestamp,
                                  'user': u,
                                  'flag': myresults[0],
                                  'iscapitalof': myresults[1],
                                  'capitalofcountry': myresults[2],
                                  'continent': myresults[3],
                                  'score': int(score)})

    def store_analysis_peaks(self):
        """ store_analysis_peaks stores the results of the analysis of
        users' use of the game per minute determined in count_minutes array
        in a csv file

        """

        with open('analysis_peaks.csv', 'wb') as csv_peaks:
            peaks_fieldnames = ['timestamp', 'minute', 'users']
            writerpk = csv.DictWriter(csv_peaks, fieldnames=peaks_fieldnames)
            # as there it no timestamp, we choose a random one (the current)
            timestamp = int(time.time()*1000)

            # for each hour
            for h in range(24):
                # for each minute
                for m in range(60):
                    users = self.count_minutes[h][m]
                    if h < 10:
                        hour = '0'+str(h)
                    else:
                        hour = str(h)
                    if m < 10:
                        minute = '0'+str(m)
                    else:
                        minute = str(m)
                    if users:
                        count = len(users)
                    else:
                        count = 0

                    # store data
                    writerpk.writerow({'timestamp': timestamp,
                                       'minute': hour+minute,
                                       'users': count})

                    # next different random timestamp
                    timestamp += 1

    def store_analysis_xapi(self):
        """ store_analysis_xapi stores the results of the analysis of
        use of xAPI verbs determined in verbs dictionary in a csv file

        """

        with open('analysis_xapi.csv', 'wb') as csv_xapi:
            xapi_fieldnames = ['timestamp', 'verb', 'times']
            writerx = csv.DictWriter(csv_xapi, fieldnames=xapi_fieldnames)

            # for each xAPI verb
            for k in self.verbs.keys():
                firstuse, times = self.verbs[k]

                # store data
                writerx.writerow({'timestamp': firstuse,
                                  'verb': k,
                                  'times': times})
